# Rich Memory Pool
一个好使的内存池
为啥要用内存池？指定是因为malloc不好使呀，为什么不好使，慢。
所以，一个内存池就是为快而生，分配快回收快。快好办，搞张位图加链表就行，嗖嗖的。
然而，速度上去了，两外一个问题来了，万一内存池规模很大搞它几十个G，那么每分配一次要浪费多少空间？
咱们当然不想浪费哪怕一个字节的空间，然而天下的好哪能让你全占了，你怎么也得浪费点空间，问题是浪费多少。
所以，内存池就两个主要问题：

1，速度要快；
2，分配一次不能浪费太多

要实现以上两点要求，得花点功夫：
1，将内存分块，用用户观点看，块是最小分配单位，比如1024字节，姑且称之为用户块；
2，程序内部用一位表示一个用户块的，分配情况，0表示空闲，1表示已占用；
3，64位占位标志组成一个0层块，这种块用户不需理会，姑且称之为索引块。64为正好为一个字，快！
4，光0层还不够快，因为如果管理个几十G，那么光0层遍历就得分析上百万个字，故此每32个字组成一个更高一层的字；
5，多了一层也不见得有多块，继续以此类推，本层每32字组成一个更高层的字；
6，为什么是32，而不是64？因为1层以上必须用两位来表示向下一层的占用情况，其中0表示空闲，11表示占用，01表示部分占用

如此一来，整个索引组织成了一棵树，利用树的特性快速游走，详情见代码，说不清楚。
总之，里面想到的都做了，分配、释放、原地扩大、原地缩小全安排。

本项目已经在gcc, g++, Visual Studio上成功编译
